{% extends "base.html" %}


{% block content %}

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    // Add IndexedDB setup
    const dbName = "audioCache";
    const dbVersion = 1;
    const storeName = "audioFiles";

    // Open/create the database
    const dbRequest = indexedDB.open(dbName, dbVersion);

    dbRequest.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(storeName)) {
        db.createObjectStore(storeName);
      }
    };

function playAudioBlobWithWebAudio(blob) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const reader = new FileReader();
  reader.onload = () => {
    ctx.decodeAudioData(reader.result, (buffer) => {
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.connect(ctx.destination);
      source.start(); // plays exactly from 0.000s, no fade
    });
  };
  reader.readAsArrayBuffer(blob);
}

    function saveAudioAndPlay(phrase) {
      fetch(`{{ api_host }}/api/audio_file/${phrase}.mp3`)
        .then(response => response.blob())
        .then(async file => {
          playAudioBlobWithWebAudio(file);
          saveAudioToBrowserDB(phrase, file);
          //playAudioFromBrowserDB(phrase);
      })
    }

    function playAudioFromBrowserDB(key) {
      const request = indexedDB.open(dbName);
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction([storeName], "readonly");
        const store = transaction.objectStore(storeName);
        const getRequest = store.get(key);

        getRequest.onsuccess = () => {
          if (getRequest.result) {
            const audioUrl = URL.createObjectURL(getRequest.result);
            const audio = new Audio(audioUrl);
            audio.play();
            /*
            setTimeout(() => {  
              audio.play();
            }, 1000);
            */
          }
        };
      };
    }

    // Helper functions for IndexedDB operations
    function saveAudioToBrowserDB(key, audioBlob) {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName);
        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction([storeName], "readwrite");
          const store = transaction.objectStore(storeName);
          const putRequest = store.put(audioBlob, key);
          putRequest.onsuccess = () => resolve();
          putRequest.onerror = () => reject(putRequest.error);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    function editRow(rowNumber) {
      console.log('editRow for row:', rowNumber);
      // Add fetch GET request to update the row
      fetch(`{{ api_host }}/api/translations/${rowNumber}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        },
      });
    }

</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

<h1>Translations</h1>
{% if not rows %}
<p>No translations yet. <a href="/">Translate something!</a></p>
{% else %}
<div class="table-container">
<table border="1">
    <tr>
        {% for lang in languages %}
        <th>{{ lang }}</th>
        {% endfor %}
        <th>Edit</th>
    </tr>
    {% for row in rows %}
    <tr>
        {% for cell in row %}
        <td>
            <div class="cell-content">
                <span>{{ cell.phrase }}</span>
                <i onclick="saveAudioAndPlay('{{ cell.phrase }}')" class="fas fa-play play-icon"></i>

            </div>
        </td>
        {% endfor %}
        <td>
          <button>
          <a href="{{ api_host }}/edit_row/{{ loop.index0 }}" class="modal-trigger">Edit</a>
          </button>
        </td>
    </tr>
    {% endfor %}
</table>
</div>
{% endif %}
{% endblock %} 